# Задача №1. Решение в группах

# Даны два массива чисел. Требуется вывести те элементы первого массива (в том порядке, 
# в каком они идут в первом массиве), которых нет во втором массиве. 
# Пользователь вводит число N - количество элементов в первом массиве, затем N чисел - 
# элементы массива. 

# Затем число M - количество элементов во втором массиве. Затем элементы второго массива.

# Ввод:                    Вывод:
# 7                        3 3 2 12
# 3 1 3 4 2 4 12
# 6
# 4 15 43 1 15 1


# 1. Решение через традиционный итератор с функцией append:

def filter_array_traditional(arr1, arr2):
    # Создаем пустой список для результата
    result = []
    # Проходим по каждому элементу первого массива
    for item in arr1:
        # Если элемент не содержится во втором массиве
        if item not in arr2:
            # Добавляем его в результат
            result.append(item)
    # Возвращаем результат
    return result

# Ввод данных
N = int(input("Введите количество элементов первого массива: "))
arr1 = list(map(int, input("Введите элементы первого массива через пробел: ").split()))
M = int(input("Введите количество элементов второго массива: "))
arr2 = list(map(int, input("Введите элементы второго массива через пробел: ").split()))

# Вывод результата
print("Элементы первого массива, которых нет во втором массиве:")
print(*filter_array_traditional(arr1, arr2))

"""
Пояснения:
1. Создается пустой список result для хранения результата.
2. В цикле for проверяется каждый элемент первого массива. Если элемент не содержится 
во втором массиве, он добавляется в result.
3. В конце функция возвращает result, который затем выводится.
"""


# 2. Решение с применением List Comprehension:

def filter_array_comprehension(arr1, arr2):
    # Используем list comprehension для создания списка элементов первого массива, которых нет во втором массиве
    return [item for item in arr1 if item not in arr2]

# Ввод данных
N = int(input("Введите количество элементов первого массива: "))
arr1 = list(map(int, input("Введите элементы первого массива через пробел: ").split()))
M = int(input("Введите количество элементов второго массива: "))
arr2 = list(map(int, input("Введите элементы второго массива через пробел: ").split()))

# Вывод результата
print("Элементы первого массива, которых нет во втором массиве:")
print(*filter_array_comprehension(arr1, arr2))

"""
Пояснения:
1. List comprehension позволяет компактно создать список элементов первого массива, 
которых нет во втором массиве.
2. Весь процесс проверки и добавления элементов в новый список происходит в одной строке.
3. Полученный список возвращается и выводится.
"""


# 3. Решение с помощью рекурсии:

def filter_array_recursive(arr1, arr2):
    # Базовый случай: если первый массив пуст, возвращаем пустой список
    if not arr1:
        return []
    # Если первый элемент первого массива не содержится во втором массиве
    if arr1[0] not in arr2:
        # Возвращаем список с этим элементом и результатом рекурсивного вызова для оставшейся части массива
        return [arr1[0]] + filter_array_recursive(arr1[1:], arr2)
    else:
        # Если элемент содержится во втором массиве, просто продолжаем рекурсивный вызов для оставшейся части массива
        return filter_array_recursive(arr1[1:], arr2)

# Ввод данных
N = int(input("Введите количество элементов первого массива: "))
arr1 = list(map(int, input("Введите элементы первого массива через пробел: ").split()))
M = int(input("Введите количество элементов второго массива: "))
arr2 = list(map(int, input("Введите элементы второго массива через пробел: ").split()))

# Вывод результата
print("Элементы первого массива, которых нет во втором массиве:")
print(*filter_array_recursive(arr1, arr2))

"""
Пояснения:
1. Базовый случай рекурсии: если первый массив пуст, возвращается пустой список.
2. Проверяется первый элемент массива arr1. Если он не содержится во втором массиве arr2, 
создается новый список, состоящий из этого элемента и результата рекурсивного вызова для 
оставшегося массива.
3. Если элемент содержится во втором массиве, просто выполняется рекурсивный вызов для 
оставшейся части массива без добавления элемента в результат.
4. Функция рекурсивно обрабатывает весь массив arr1 и возвращает список элементов, 
которых нет во втором массиве.
"""